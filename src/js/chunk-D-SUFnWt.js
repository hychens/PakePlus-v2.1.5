import{v as t,c as e,i as n,A as s,m as o,B as c,C as a,r,d as i,e as u,g as f,o as l,w as p,n as h,p as d,D as y}from"./chunk-BG8DtHa0.js";let b;const v=t=>b=t,_=Symbol();function j(t){return t&&"object"==typeof t&&"[object Object]"===Object.prototype.toString.call(t)&&"function"!=typeof t.toJSON}var S,m;function O(){const t=u(!0),e=t.run(()=>r({}));let n=[],s=[];const o=y({install(t){v(o),o._a=t,t.provide(_,o),t.config.globalProperties.$pinia=o,s.forEach(t=>n.push(t)),s=[]},use(t){return this._a?n.push(t):s.push(t),this},_p:n,_a:null,_e:t,_s:new Map,state:e});return o}(m=S||(S={})).direct="direct",m.patchObject="patch object",m.patchFunction="patch function";const $=()=>{};function g(t,e,n,s=$){t.add(e);const o=()=>{t.delete(e)&&s()};return!n&&f()&&l(o),o}function w(t,...e){t.forEach(t=>{t(...e)})}const P=t=>t(),E=Symbol(),A=Symbol();function I(t,e){t instanceof Map&&e instanceof Map?e.forEach((e,n)=>t.set(n,e)):t instanceof Set&&e instanceof Set&&e.forEach(t.add,t);for(const o in e){if(!e.hasOwnProperty(o))continue;const c=e[o],a=t[o];j(a)&&j(c)&&t.hasOwnProperty(o)&&!n(c)&&!s(c)?t[o]=I(a,c):t[o]=c}return t}const M=Symbol();function k(t){return!j(t)||!Object.prototype.hasOwnProperty.call(t,M)}const{assign:x}=Object;function C(t){return!(!n(t)||!t.effect)}function F(e,o,c={},a,f,l){let d;const y=x({actions:{}},c),b={deep:!0};let _,j,m,O=new Set,M=new Set;const F=a.state.value[e];let B;function D(t){let n;_=j=!1,"function"==typeof t?(t(a.state.value[e]),n={type:S.patchFunction,storeId:e,events:m}):(I(a.state.value[e],t),n={type:S.patchObject,payload:t,storeId:e,events:m});const s=B=Symbol();h().then(()=>{B===s&&(_=!0)}),j=!0,w(O,n,a.state.value[e])}l||F||(a.state.value[e]={}),r({});const J=l?function(){const{state:t}=c,e=t?t():{};this.$patch(t=>{x(t,e)})}:$;const N=(t,n="")=>{if(E in t)return t[A]=n,t;const s=function(){v(a);const n=Array.from(arguments),o=new Set,c=new Set;let r;w(M,{args:n,name:s[A],store:q,after:function(t){o.add(t)},onError:function(t){c.add(t)}});try{r=t.apply(this&&this.$id===e?this:q,n)}catch(i){throw w(c,i),i}return r instanceof Promise?r.then(t=>(w(o,t),t)).catch(t=>(w(c,t),Promise.reject(t))):(w(o,r),r)};return s[E]=!0,s[A]=n,s},W={_p:a,$id:e,$onAction:g.bind(null,M),$patch:D,$reset:J,$subscribe(t,n={}){const s=g(O,t,n.detached,()=>o()),o=d.run(()=>p(()=>a.state.value[e],s=>{("sync"===n.flush?j:_)&&t({storeId:e,type:S.direct,events:m},s)},x({},b,n)));return s},$dispose:function(){d.stop(),O.clear(),M.clear(),a._s.delete(e)}},q=i(W);a._s.set(e,q);const z=(a._a&&a._a.runWithContext||P)(()=>a._e.run(()=>(d=u()).run(()=>o({action:N}))));for(const t in z){const o=z[t];if(n(o)&&!C(o)||s(o))l||(F&&k(o)&&(n(o)?o.value=F[t]:I(o,F[t])),a.state.value[e][t]=o);else if("function"==typeof o){const e=N(o,t);z[t]=e,y.actions[t]=o}}return x(q,z),x(t(q),z),Object.defineProperty(q,"$state",{get:()=>a.state.value[e],set:t=>{D(e=>{x(e,t)})}}),a._p.forEach(t=>{x(q,d.run(()=>t({store:q,app:a._a,pinia:a,options:y})))}),F&&l&&c.hydrate&&c.hydrate(q.$state,F),_=!0,j=!0,q}function B(t,n,s){let o;const r="function"==typeof n;function i(s,i){const u=a();(s=s||(u?c(_,null):null))&&v(s),(s=b)._s.has(t)||(r?F(t,n,o,s):function(t,n,s){const{state:o,actions:c,getters:a}=n,r=s.state.value[t];let i;i=F(t,function(){r||(s.state.value[t]=o?o():{});const n=d(s.state.value[t]);return x(n,c,Object.keys(a||{}).reduce((n,o)=>(n[o]=y(e(()=>{v(s);const e=s._s.get(t);return a[o].call(e,e)})),n),{}))},n,s,0,!0)}(t,o,s));return s._s.get(t)}return o=r?s:n,i.$id=t,i}function D(c){const a=t(c),r={};for(const t in a){const i=a[t];i.effect?r[t]=e({get:()=>c[t],set(e){c[t]=e}}):(n(i)||s(i))&&(r[t]=o(c,t))}return r}export{O as c,B as d,D as s};
